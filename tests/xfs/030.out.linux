QA output created by 030
meta-data=DDEV isize=XXX agcount=N, agsize=XXX blks
data     = bsize=XXX blocks=XXX, imaxpct=PCT
         = sunit=XXX swidth=XXX, unwritten=X
naming   =VERN bsize=XXX
log      =LDEV bsize=XXX blocks=XXX
realtime =RDEV extsz=XXX blocks=XXX, rtextents=XXX
Corrupting sb 0 - setting bits to 0
Wrote X.XXKb (value 0x0)
Phase 1 - find and verify superblock...
bad primary superblock - bad magic number !!!

attempting to find secondary superblock...
found candidate secondary superblock...
verified secondary superblock...
writing modified primary superblock
sb root inode value INO inconsistent with calculated value INO
resetting superblock root inode pointer to INO
sb realtime bitmap inode INO inconsistent with calculated value INO
resetting superblock realtime bitmap ino pointer to INO
sb realtime summary inode INO inconsistent with calculated value INO
resetting superblock realtime summary ino pointer to INO
Phase 2 - using <TYPEOF> log
        - zero log...
        - scan filesystem freespace and inode maps...
        - found root inode chunk
Phase 3 - for each AG...
        - scan and clear agi unlinked lists...
        - process known inodes and perform inode discovery...
        - process newly discovered inodes...
Phase 4 - check for duplicate blocks...
        - setting up duplicate extent list...
        - check for inodes claiming duplicate blocks...
Phase 5 - rebuild AG headers and trees...
        - reset superblock...
Phase 6 - check inode connectivity...
        - resetting contents of realtime bitmap and summary inodes
        - traversing filesystem ...
        - traversal finished ...
        - moving disconnected inodes to lost+found ...
Phase 7 - verify and correct link counts...
Note - stripe unit (SU) and width (SW) fields have been reset.
Please set with mount -o sunit=<value>,swidth=<value>
done
Corrupting agf 0 - setting bits to 0
Wrote X.XXKb (value 0x0)
Phase 1 - find and verify superblock...
Phase 2 - using <TYPEOF> log
        - zero log...
        - scan filesystem freespace and inode maps...
bad magic # 0x0 for agf 0
bad version # 0 for agf 0
bad length 0 for agf 0, should be LENGTH
reset bad agf for ag 0
bad agbno AGBNO for btbno root, agno 0
bad agbno AGBNO for btbcnt root, agno 0
        - found root inode chunk
Phase 3 - for each AG...
        - scan and clear agi unlinked lists...
        - process known inodes and perform inode discovery...
        - process newly discovered inodes...
Phase 4 - check for duplicate blocks...
        - setting up duplicate extent list...
        - check for inodes claiming duplicate blocks...
Phase 5 - rebuild AG headers and trees...
        - reset superblock...
Phase 6 - check inode connectivity...
        - resetting contents of realtime bitmap and summary inodes
        - traversing filesystem ...
        - traversal finished ...
        - moving disconnected inodes to lost+found ...
Phase 7 - verify and correct link counts...
done
Corrupting agi 0 - setting bits to 0
Wrote X.XXKb (value 0x0)
Phase 1 - find and verify superblock...
Phase 2 - using <TYPEOF> log
        - zero log...
        - scan filesystem freespace and inode maps...
bad magic # 0x0 for agi 0
bad version # 0 for agi 0
bad length # 0 for agi 0, should be LENGTH
reset bad agi for ag 0
bad agbno AGBNO for inobt root, agno 0
root inode chunk not found
Phase 3 - for each AG...
        - scan and clear agi unlinked lists...
        - process known inodes and perform inode discovery...
        - process newly discovered inodes...
Phase 4 - check for duplicate blocks...
        - setting up duplicate extent list...
        - check for inodes claiming duplicate blocks...
Phase 5 - rebuild AG headers and trees...
        - reset superblock...
Phase 6 - check inode connectivity...
        - resetting contents of realtime bitmap and summary inodes
        - traversing filesystem ...
        - traversal finished ...
        - moving disconnected inodes to lost+found ...
Phase 7 - verify and correct link counts...
done
Corrupting agfl 0 - setting bits to 0
Wrote X.XXKb (value 0x0)
Phase 1 - find and verify superblock...
Phase 2 - using <TYPEOF> log
        - zero log...
        - scan filesystem freespace and inode maps...
        - found root inode chunk
Phase 3 - for each AG...
        - scan and clear agi unlinked lists...
        - process known inodes and perform inode discovery...
        - process newly discovered inodes...
Phase 4 - check for duplicate blocks...
        - setting up duplicate extent list...
        - check for inodes claiming duplicate blocks...
Phase 5 - rebuild AG headers and trees...
        - reset superblock...
Phase 6 - check inode connectivity...
        - resetting contents of realtime bitmap and summary inodes
        - traversing filesystem ...
        - traversal finished ...
        - moving disconnected inodes to lost+found ...
Phase 7 - verify and correct link counts...
done
Corrupting sb 0 - setting bits to -1
Wrote X.XXKb (value 0xffffffff)
Phase 1 - find and verify superblock...
bad primary superblock - bad magic number !!!

attempting to find secondary superblock...
found candidate secondary superblock...
verified secondary superblock...
writing modified primary superblock
sb root inode value INO inconsistent with calculated value INO
resetting superblock root inode pointer to INO
sb realtime bitmap inode INO inconsistent with calculated value INO
resetting superblock realtime bitmap ino pointer to INO
sb realtime summary inode INO inconsistent with calculated value INO
resetting superblock realtime summary ino pointer to INO
Phase 2 - using <TYPEOF> log
        - zero log...
        - scan filesystem freespace and inode maps...
        - found root inode chunk
Phase 3 - for each AG...
        - scan and clear agi unlinked lists...
        - process known inodes and perform inode discovery...
        - process newly discovered inodes...
Phase 4 - check for duplicate blocks...
        - setting up duplicate extent list...
        - check for inodes claiming duplicate blocks...
Phase 5 - rebuild AG headers and trees...
        - reset superblock...
Phase 6 - check inode connectivity...
        - resetting contents of realtime bitmap and summary inodes
        - traversing filesystem ...
        - traversal finished ...
        - moving disconnected inodes to lost+found ...
Phase 7 - verify and correct link counts...
Note - stripe unit (SU) and width (SW) fields have been reset.
Please set with mount -o sunit=<value>,swidth=<value>
done
Corrupting agf 0 - setting bits to -1
Wrote X.XXKb (value 0xffffffff)
Phase 1 - find and verify superblock...
Phase 2 - using <TYPEOF> log
        - zero log...
        - scan filesystem freespace and inode maps...
bad magic # 0xffffffff for agf 0
bad version # -1 for agf 0
bad sequence # -1 for agf 0
bad length -1 for agf 0, should be LENGTH
flfirst -1 in agf 0 too large (max = MAX)
fllast -1 in agf 0 too large (max = MAX)
reset bad agf for ag 0
freeblk count 1 != flcount -1 in ag 0
bad agbno AGBNO for btbno root, agno 0
bad agbno AGBNO for btbcnt root, agno 0
        - found root inode chunk
Phase 3 - for each AG...
        - scan and clear agi unlinked lists...
        - process known inodes and perform inode discovery...
        - process newly discovered inodes...
Phase 4 - check for duplicate blocks...
        - setting up duplicate extent list...
        - check for inodes claiming duplicate blocks...
Phase 5 - rebuild AG headers and trees...
        - reset superblock...
Phase 6 - check inode connectivity...
        - resetting contents of realtime bitmap and summary inodes
        - traversing filesystem ...
        - traversal finished ...
        - moving disconnected inodes to lost+found ...
Phase 7 - verify and correct link counts...
done
Corrupting agi 0 - setting bits to -1
Wrote X.XXKb (value 0xffffffff)
Phase 1 - find and verify superblock...
Phase 2 - using <TYPEOF> log
        - zero log...
        - scan filesystem freespace and inode maps...
bad magic # 0xffffffff for agi 0
bad version # -1 for agi 0
bad sequence # -1 for agi 0
bad length # -1 for agi 0, should be LENGTH
reset bad agi for ag 0
bad agbno AGBNO for inobt root, agno 0
root inode chunk not found
Phase 3 - for each AG...
        - scan and clear agi unlinked lists...
        - process known inodes and perform inode discovery...
        - process newly discovered inodes...
Phase 4 - check for duplicate blocks...
        - setting up duplicate extent list...
        - check for inodes claiming duplicate blocks...
Phase 5 - rebuild AG headers and trees...
        - reset superblock...
Phase 6 - check inode connectivity...
        - resetting contents of realtime bitmap and summary inodes
        - traversing filesystem ...
        - traversal finished ...
        - moving disconnected inodes to lost+found ...
Phase 7 - verify and correct link counts...
done
Corrupting agfl 0 - setting bits to -1
Wrote X.XXKb (value 0xffffffff)
Phase 1 - find and verify superblock...
Phase 2 - using <TYPEOF> log
        - zero log...
        - scan filesystem freespace and inode maps...
bad agbno AGBNO in agfl, agno 0
        - found root inode chunk
Phase 3 - for each AG...
        - scan and clear agi unlinked lists...
        - process known inodes and perform inode discovery...
        - process newly discovered inodes...
Phase 4 - check for duplicate blocks...
        - setting up duplicate extent list...
        - check for inodes claiming duplicate blocks...
Phase 5 - rebuild AG headers and trees...
        - reset superblock...
Phase 6 - check inode connectivity...
        - resetting contents of realtime bitmap and summary inodes
        - traversing filesystem ...
        - traversal finished ...
        - moving disconnected inodes to lost+found ...
Phase 7 - verify and correct link counts...
done
