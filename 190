#! /bin/sh
# FSQA Test No. 190
#
# This test uses xfs_io to unreserve space in a file at various different
# offsets and sizes. The script then verifies the holes are in the correct
# location.
#
# PV 985792
#-----------------------------------------------------------------------
#  Copyright (c) 2008 Silicon Graphics, Inc.  All Rights Reserved.
#-----------------------------------------------------------------------
#
# creator
owner=pleckie@sgi.com

#This is the list of holes to punch in the file limited to $filesize
#NOTE holes cannot overlap or this script will fail.
holes="4096:4096 303104:4096 1048576:512 1051648:8192 1065984:8192 1085440:7168"
#filesize in MB
filesize=10
#Name of file to perform the test on
filename=test-190
fsblocksize=4096

seq=`basename $0`
echo "QA output created by $seq"

here=`pwd`
tmp=/tmp/$$
status=0    # success is the default!
rm -f $seq.full

# get standard environment, filters and checks
. ./common.rc
. ./common.filter

# real QA test starts here
_supported_fs xfs
_supported_os Linux

_require_scratch
_scratch_mkfs_xfs >/dev/null 2>&1
_scratch_mount


dd if=/dev/zero of=$SCRATCH_MNT/$filename bs=1024k count=10 >> $seq.full 2>&1

# run DMAPI test using verbose output
echo Punching holes in file
echo Punching holes in file >> $seq.full
for i in $holes ; do
	echo xfs_io -c "unresvsp `echo $i |$SED_PROG 's/:/ /g'`" $SCRATCH_MNT/$filename >> $seq.full
	xfs_io -c "unresvsp `echo $i |$SED_PROG 's/:/ /g'`" $SCRATCH_MNT/$filename ;
done

echo Verifying holes are in the correct spots:

xfs_bmap=`xfs_bmap $SCRATCH_MNT/$filename`
xfs_bmap $SCRATCH_MNT/$filename >> $seq.full
for i in $holes ; do
	holeStart=$[`echo $i|$SED_PROG 's/:/ /g'|awk '{print $1}'`];
	holeEnd=$[`echo $i|$SED_PROG 's/:/ /g'|awk '{print $2}'`];

	#Round hole size down to a multiple of $fsblocksize
	holeEnd=$[(($holeStart+$holeEnd)/$fsblocksize)*$fsblocksize]

	#Round hole start up to a multiple of $fsblocksize
	if [ $[$holeStart % $fsblocksize] -gt 0 ] ; then
		holeStart=$[($holeStart/$fsblocksize +1) * $fsblocksize]
	fi
	#xfs_bmap prints holes in the following format
	#                1: [8..15]: hole
	bmap="\[$[$holeStart/512]..$[($holeEnd/512) -1]\]";
	echo $bmap >> $seq.full
	if [ $holeEnd == $holeStart ] ; then
		continue #there is no hole
	fi
	if ! echo $xfs_bmap|grep -q $bmap; then
		echo Offset $holeStart to $holeEnd  basic blocks failed;
		status=1;
	fi
done
if [ $status == 0 ] ; then
	echo Test $seq Passed.
fi

exit
